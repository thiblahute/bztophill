#!/usr/bin/env python3

"""Converts Bugzilla XML files to something Phabricator's Phill may like.

Usage:
  bzxmltophill <bz.xml> [--base-url=url -od]

Options:
  --base-url=url  The default base URL for projects and tasks
  -od=outfiles_dir Were to put generated/downloaded files
  -h --help       Show this screen.
  --version       Show version.
"""

from docopt import docopt
from datetime import datetime
import xml.etree.ElementTree as ET
import json
import os
import re
import base64

DEFAULT_SERVER = 'https://bugzilla.gnome.org'

try:
    from config import project_ids
except:
    project_ids = {}

try:
    from config import project_names
except:
    project_ids = {}

class Converter:
    def __init__(self, outfiles_dir):
        self.root = None
        self.projects = []
        self.tasks = []
        self.base_url = DEFAULT_SERVER
        self.outfiles_dir = outfiles_dir
        self.attachments_dir = os.path.join(outfiles_dir, "attachements")

    def set_base_url(self, url):
        if url:
            self.base_url = url

    def url(self, i):
        return self.base_url + "/show_bug.cgi?id=" + i.findtext("bug_id")

    def load(self, filename):
        try:
            os.mkdir(self.attachments_dir)
        except FileExistsError:
            pass

        self.root = ET.parse(filename).getroot()

    def convert(self):
        self.projects_convert()
        self.issues_convert()
        r = {
            'projects': self.projects,
            'tasks': self.tasks
        }
        return r

    def date_to_iso(self, datestr):
        iso = datetime.strptime(datestr, '%Y-%m-%d %H:%M:%S +%f').isoformat()
        return iso

    def user_email(self, key):
        return self.bytype['users'][key]['emailAddress']

    def markup_parse(self, markup):
        if not markup:
            return None
        # turn [text|link] to [[link|text]]
        markup = re.sub(r'\[(.*)\|(.*)\]', r'[[\2|\1]]', markup)
        # turn {{code}} to ##code##
        markup = re.sub(r'{{(.*?)}}', r'##\1##', markup)
        markup = markup.replace('{code}', '```')
        return markup

    def get_project_ids(self, bug):
        id_cleaner = re.compile('[^a-zA-Z]')
        product_id = project_ids.get(bug.findtext("product"),
                                     id_cleaner.sub("", bug.findtext("product")).upper())

        product_name = self.clean_project_name(bug.findtext("product"))

        component_id = project_ids.get(bug.findtext("component"),
                                       id_cleaner.sub("", bug.findtext("component")).upper())
        component_name = self.clean_project_name(bug.findtext("component"))

        return [(product_id, product_name),
                (component_id, component_name)]

    def clean_project_name(self, name):
        try:
            return project_names[name]
        except KeyError:
            return name.replace("-", " ").replace("_", " ")

    def projects_convert(self):
        all_projects = {}
        for bug in self.root.findall('bug'):

            project_ids = self.get_project_ids(bug)
            for project_id, project_name in project_ids:
                project = all_projects.get(project_id)
                if not project:
                    project = self.create_project(project_id,
                                                  project_name,
                                                  bug)
                    all_projects[project_id] = project

    def create_project(self, pid, name, bug):
        ret = {
            'id': pid,
            'name': name,
            'description': "Please add a project description",
            'tracker': 'Bugzilla',
            'url': "%s/buglist.cgi?component=%s&product=%s" % (self.base_url, bug.findtext("component"), bug.findtext("product")),
            'creator': bug.findtext("assigned_to"),
            'creationDate': self.date_to_iso(bug.findtext("creation_ts")),
        }

        members = []
        for bug in self.root.findall('bug'):
            members.append(bug.findtext("reporter"))
            members.append(bug.findtext("assigned_to"))
            for member in bug.findall("cc"):
                members.append(member.text)

        ret['members'] = list(set(members))
        self.projects.append(ret)
        return ret

    def transaction_create(self, actor, date, kind, value=None, comment=None):
        ret = {
            'actor': actor,
            'date': date,
            'type': kind,
        }
        if value is not None:
            ret['value'] = value
        if comment:
            ret['comment'] = comment
        return ret

    def issues_convert(self):
        for bug in self.root.findall("bug"):
            self.issue_convert(bug)
        if len(self.tasks) == 10000:
            print("Exactly 10 000 tasks, *most* probably due to reaching"
                  " the hard limit of XML downloading from the bugzilla"
                  " server -- you should download the database in smaller"
                  " pieces")
            exit(1)

    def priority_parse(self, severity):
        m = {
            "blocker": 100,
            "critical": 80,
            "major": 80,
            "normal": 50,
            "minor": 25,
            "trivial": 25,
            "enhancement": 0,
        }

        return m[severity]

    def status_parse(self, bug):
        status = bug.findtext("bug_status")
        resolution = bug.findtext("resolution")
        if resolution:
            status = resolution

        m = {
            "NEW": "open",
            "REOPENED": "open",
            "NEEDINFO": "open",
            "ASSIGNED": "open",
            "FIXED": "resolved",
            "INCOMPLETE": "spite",
            "NOTGNOME": "spite",
            "NOTABUG": "spite",
            "WONTFIX": "spite",
            "INVALID": "spite",
            "OBSOLETE": "spite",
            "DUPLICATE": "duplicate",
            "UNCONFIRMED": "open",
        }
        return m[status]

    def find_attachement(self, bug, id):
        for attachment in bug.findall("attachment"):
            if attachment.findtext("attachid") == id:
                return attachment

        return None

    def get_attachement(self, attachment):
        fpath = os.path.join("attachements", "%s-%s" % (attachment.findtext("attachid"), attachment.findtext("filename")))
        output = os.path.join(self.attachments_dir, "%s-%s" % (attachment.findtext("attachid"), attachment.findtext("filename")))
        if os.path.exists(output):
            return fpath

        data = attachment.findtext("data")
        if data:
            data = base64.b64decode(data)
            open(output, "wb").write(data)

            return fpath

        return self.download_attachement(attachment)

    def download_attachement(self, attachment):
        fpath = os.path.join("attachements", "%s-%s" % (attachment.findtext("attachid"), attachment.findtext("filename")))
        output = os.path.join(self.outfiles_dir, "%s-%s" % (attachment.findtext("attachid"), attachment.findtext("filename")))
        os.system("wget '%s/attachment.cgi?id=%s' -O '%s'"
                  % (self.base_url, attachment.findtext("attachid"), output))

        return fpath

    def convert_transactions(self, bug):
        transactions = []

        transactions.append(self.transaction_create(bug.findtext("assigned_to"),
                                                    self.date_to_iso(bug.findtext("creation_ts")),
                                                    "projects",
                                                    {'=': [id_name[0] for id_name in self.get_project_ids(bug)]}))

        for comment in bug.findall("long_desc")[1:]:
            attachid = comment.find("attachid")
            if attachid is not None:
                attachid = attachid.text
                attachment = self.find_attachement(bug, attachid)

                value = {
                    'author': attachment.findtext("attacher"),
                    'data': self.get_attachement(attachment),
                    'name': attachment.findtext("filename"),
                    'mimetype': attachment.findtext("type"),
                    'ispatch': attachment.attrib["ispatch"],
                    'isobsolete': attachment.attrib["isobsolete"],
                    'patchstatus': attachment.findtext("gnome_attachment_status"),
                }

                transaction = self.transaction_create(comment.findtext("who"),
                                                      self.date_to_iso(comment.findtext("bug_when")),
                                                      "attachment",
                                                      value)
                transactions.append(transaction)

            transaction = self.transaction_create(comment.findtext("who"),
                                                  self.date_to_iso(comment.findtext("bug_when")),
                                                  "comment",
                                                  comment=comment.findtext("thetext"))
            transactions.append(transaction)

        transactions.append(self.transaction_create(bug.findtext("assigned_to"),
                                                    self.date_to_iso(bug.findtext("creation_ts")),
                                                    "priority",
                                                    self.priority_parse(bug.findtext("bug_severity"))))

        transactions.append(self.transaction_create(bug.findtext("assigned_to"),
                                                    self.date_to_iso(bug.findtext("creation_ts")),
                                                    "status",
                                                    self.status_parse(bug)))

        transactions.append(self.transaction_create(bug.findtext("assigned_to"),
                                                    self.date_to_iso(bug.findtext("creation_ts")),
                                                    "owner",
                                                    bug.findtext("assigned_to")))

        transactions.append(self.transaction_create(bug.findtext("assigned_to"),
                                                    self.date_to_iso(bug.findtext("creation_ts")),
                                                    "owner",
                                                    bug.findtext("assigned_to")))

        for cc in bug.findall("cc"):
            transactions.append(self.transaction_create(bug.findtext("assigned_to"),
                                                        self.date_to_iso(bug.findtext("creation_ts")),
                                                        "subscribers",
                                                        {"+": [cc.text]}))

        return transactions

    def issue_convert(self, i):
        reporter = i.findtext("reporter")
        date = self.date_to_iso(i.findtext("creation_ts"))
        ret = {
            'id': i.findtext("bug_id"),
            'url': self.url(i),
            'title': i.findtext("short_desc"),
            'creationDate': date,
            'creator': reporter,
            'description': i.find("long_desc").findtext("thetext"),
            'transactions': self.convert_transactions(i)
        }
        self.tasks.append(ret)


def main(arguments):
    filename = arguments['<bz.xml>']
    outfiles_dir = arguments.get('-od', "outfiles")

    try:
        os.mkdir(outfiles_dir)
    except FileExistsError:
        pass

    outfile = os.path.join(outfiles_dir, os.path.splitext(os.path.basename(filename))[0]) + '.json'
    converter = Converter(outfiles_dir)
    if '--base-url' in arguments:
        converter.set_base_url(arguments['--base-url'])

    converter.load(filename)
    data = converter.convert()

    open(outfile, 'w').write(json.dumps(data, sort_keys=True, indent=4))

if __name__ == '__main__':
    arguments = docopt(__doc__, version='bztophill 0.1')
    main(arguments)
